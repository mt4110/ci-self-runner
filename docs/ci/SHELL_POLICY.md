# SHELL_POLICY（バランス型 / Go中心 + Shell極薄）

## 目的

このリポジトリは「長期破綻しない運用」を優先する。
Shell は便利だが、複雑化すると再現性・保守性・安全性が落ちやすい。
よって **ロジックはGoに寄せ、Shellは“起動だけ”** に限定する。

## 結論（採用方針）

- **Goが正**：判定・分岐・ループ・パース・I/O・証拠生成・ログ整形はGoで実装する
- **Shellは極薄ラッパ**：docker/go の呼び出し、環境変数、ディレクトリ準備のみ

この方針により、
- コードレビューが容易
- 事故が減る（曖昧なパイプ/パースを排除）
- CI/ローカルの挙動が揃う
- Codexが“自由にやりすぎる”余地が減る

---

## Shellの許可範囲（OK）

Shellでやってよいことは **“起動と準備”** のみ。

### OK例（許可）

- `docker run ...` の起動（引数整形も最小）
- Goツール/バイナリの起動（`go run` / `./bin/...`）
- 環境変数の設定（例：`CI=1`）
- ディレクトリ準備（`mkdir -p`、`cp`、`rm -f` 程度）
- 表示（`echo`）と最小限の存在確認（`test -f` 程度）

---

## Shellの禁止範囲（NG）

以下は **原則禁止**。やるならGoへ移す。

### NG：ロジック

- `if/elif/else`
- `for/while/until`
- `case`
- 関数定義（`foo(){...}`）や複雑なスクリプト構造

### NG：文字列パースでの意思決定

- `awk/sed/grep` を組み合わせて判定ロジックを作る
- `cut` や `tr` を多段で使う
- `xargs` で状態機械っぽいことをする

### NG：危険な制御

- `set -e` / `set -euo pipefail`（対話環境で落ちる事故の元）
- `trap EXIT`（終了コード依存の制御）
- `exit 1` / `return 1` で全体フローを止める設計
  - 本リポの方針：失敗は `ERROR:` を出し、次へ進まない判断は“フラグ/条件”で制御する

### NG：ネットワーク依存

- `curl` で何かを取ってきて実行
- ランタイムで外部依存を増やす

---

## “極薄”の定義（守る）

Shellラッパは以下を満たすこと。

- **30行以内**
- パイプ（`|`）は **原則1回まで**（できれば0）
- “判定”はしない（するならGoへ）
- 失敗は **OK/ERROR/SKIP** の行を残す（黙って死なない）
- 実行契約（/repo /out /cache など）を守る

---

## 例外運用（どうしてもShellでやる場合）

以下のいずれかを満たす場合に限り、例外を認める。

- Goで書くと依存が増えるだけで、Shellが明確に短くなる
- 実装が **10行以下** で、分岐/ループ/パースがない
- 例外理由を `docs/ci/RUNBOOK.md` に1行残す（“なぜGoにしなかったか”）

---

## 影響範囲（CI/運用）

- GitHub Actions 内での Shell は **ワンライナー程度**に抑える
- まとまった処理は必ずGoへ移す

---

## Codex向けルール（破ったら差し戻し）

Codexは以下を厳守すること。

- Shellで分岐/ループ/パース/状態管理を実装しない
- “便利そう”で新しいShellスクリプトを増やさない
- 必要な処理はGoの `cmd/` or `internal/` に実装し、Shellは起動のみ

**違反があった場合、そのPRは差し戻し（revert or fix）対象**。
