package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

func main() {
	defer func() {
		if r := recover(); r != nil {
			writeStatusFile("out", "ERROR", fmt.Sprintf("panic=%v", r), false)
			fmt.Printf("ERROR: verify_full_host panic=%v\n", r)
			fmt.Println("STATUS: ERROR")
		}
	}()

	outDir := envOr("OUT_DIR", "out")
	_ = os.MkdirAll(outDir, 0o755)

	dryRun := isDryRun()

	fmt.Println("OK: verify_full_host start")
	fmt.Printf("OK: mode=%s\n", modeLabel(dryRun))

	// Remove stale status file (prevent previous-run contamination)
	statusPath := filepath.Join(outDir, "verify-full.status")
	_ = os.Remove(statusPath)

	// Build the command
	args := []string{"ops/ci/run_verify_full.sh"}
	env := os.Environ()
	if dryRun {
		env = appendEnv(env, "VERIFY_DRY_RUN", "1")
	}
	env = appendEnv(env, "VERIFY_GHA_SYNC", envOr("VERIFY_GHA_SYNC", "0"))

	cmd := exec.Command("sh", args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Env = env
	err := cmd.Run()

	// SOT: read the status file generated by verify-full inside the container
	st := readStatusFromFile(statusPath)

	if st == "" {
		// Status file was not generated â€” force ERROR status
		reason := "status_file_missing"
		if err != nil {
			reason = "command_failed_and_status_file_missing(" + err.Error() + ")"
		}
		writeStatusFile(outDir, "ERROR", reason, dryRun)
		fmt.Printf("ERROR: verify_full_host %s\n", reason)
		fmt.Println("STATUS: ERROR")
		return
	}

	fmt.Printf("OK: verify_full_host sot=%s status=%s\n", statusPath, st)
	fmt.Printf("STATUS: %s\n", st)
}

func isDryRun() bool {
	for _, arg := range os.Args[1:] {
		if arg == "--dry-run" {
			return true
		}
	}
	return parseBool(os.Getenv("VERIFY_DRY_RUN"))
}

func parseBool(raw string) bool {
	switch strings.ToLower(strings.TrimSpace(raw)) {
	case "1", "true", "yes", "on":
		return true
	default:
		return false
	}
}

func modeLabel(dryRun bool) string {
	if dryRun {
		return "dry-run"
	}
	return "full"
}

func readStatusFromFile(path string) string {
	content, err := os.ReadFile(path)
	if err != nil {
		return ""
	}
	text := string(content)
	for _, line := range strings.Split(text, "\n") {
		if strings.Contains(line, "status=OK") {
			return "OK"
		}
		if strings.Contains(line, "status=ERROR") {
			return "ERROR"
		}
		if strings.Contains(line, "status=SKIP") {
			return "SKIP"
		}
	}
	return ""
}

func writeStatusFile(outDir, status, reason string, dryRun bool) {
	_ = os.MkdirAll(outDir, 0o755)
	stamp := time.Now().UTC().Format("20060102T150405Z")
	head := "OK"
	switch strings.ToUpper(status) {
	case "ERROR":
		head = "ERROR"
	case "SKIP":
		head = "SKIP"
	}
	lines := []string{
		fmt.Sprintf("%s: verify-full status=%s mode=%s", head, status, modeLabel(dryRun)),
		fmt.Sprintf("timestamp=%s", stamp),
		fmt.Sprintf("status=%s", status),
		fmt.Sprintf("mode=%s", modeLabel(dryRun)),
		fmt.Sprintf("source=verify_full_host"),
	}
	if reason != "" {
		lines = append(lines, "ERROR: reason="+reason)
		lines = append(lines, "reason="+reason)
	}
	content := strings.Join(lines, "\n") + "\n"
	_ = os.WriteFile(filepath.Join(outDir, "verify-full.status"), []byte(content), 0o644)
}

func appendEnv(env []string, key, value string) []string {
	prefix := key + "="
	for i, e := range env {
		if strings.HasPrefix(e, prefix) {
			env[i] = prefix + value
			return env
		}
	}
	return append(env, prefix+value)
}

func envOr(key, fallback string) string {
	v := os.Getenv(key)
	if v == "" {
		return fallback
	}
	return v
}
