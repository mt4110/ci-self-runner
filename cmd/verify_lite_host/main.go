package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

func main() {
	defer func() {
		if r := recover(); r != nil {
			writeStatusFile("out", "ERROR", fmt.Sprintf("panic=%v", r))
			fmt.Printf("ERROR: verify_lite_host panic=%v\n", r)
			fmt.Println("STATUS: ERROR")
		}
	}()

	outDir := envOr("OUT_DIR", "out")
	_ = os.MkdirAll(outDir, 0o755)

	fmt.Println("OK: verify_lite_host start")

	cmd := exec.Command("go", "run", "./cmd/verify-lite")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err := cmd.Run()

	// SOT: read the status file generated by verify-lite itself
	statusPath := filepath.Join(outDir, "verify-lite.status")
	st := readStatusFromFile(statusPath)

	if st == "" {
		// Status file was not generated â€” force ERROR status
		reason := "status_file_missing"
		if err != nil {
			reason = "command_failed_and_status_file_missing(" + err.Error() + ")"
		}
		writeStatusFile(outDir, "ERROR", reason)
		fmt.Printf("ERROR: verify_lite_host %s\n", reason)
		fmt.Println("STATUS: ERROR")
		return
	}

	fmt.Printf("OK: verify_lite_host sot=%s status=%s\n", statusPath, st)
	fmt.Printf("STATUS: %s\n", st)
}

func readStatusFromFile(path string) string {
	content, err := os.ReadFile(path)
	if err != nil {
		return ""
	}
	text := string(content)
	for _, line := range strings.Split(text, "\n") {
		if strings.Contains(line, "status=OK") {
			return "OK"
		}
		if strings.Contains(line, "status=ERROR") {
			return "ERROR"
		}
		if strings.Contains(line, "status=SKIP") {
			return "SKIP"
		}
	}
	return ""
}

func writeStatusFile(outDir, status, reason string) {
	_ = os.MkdirAll(outDir, 0o755)
	stamp := time.Now().UTC().Format("20060102T150405Z")
	head := "OK"
	switch strings.ToUpper(status) {
	case "ERROR":
		head = "ERROR"
	case "SKIP":
		head = "SKIP"
	}
	lines := []string{
		fmt.Sprintf("%s: verify-lite status=%s", head, status),
		fmt.Sprintf("timestamp=%s", stamp),
		fmt.Sprintf("status=%s", status),
		fmt.Sprintf("source=verify_lite_host"),
	}
	if reason != "" {
		lines = append(lines, "ERROR: reason="+reason)
		lines = append(lines, "reason="+reason)
	}
	content := strings.Join(lines, "\n") + "\n"
	_ = os.WriteFile(filepath.Join(outDir, "verify-lite.status"), []byte(content), 0o644)
}

func envOr(key, fallback string) string {
	v := os.Getenv(key)
	if v == "" {
		return fallback
	}
	return v
}
